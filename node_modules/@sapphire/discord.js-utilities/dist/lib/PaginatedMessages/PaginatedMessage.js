"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaginatedMessage = void 0;
require("@sapphire/time-utilities");
const utilities_1 = require("@sapphire/utilities");
const discord_js_1 = require("discord.js");
const MessageBuilder_1 = require("../builders/MessageBuilder");
const type_guards_1 = require("../type-guards");
const utils_1 = require("./utils");
/**
 * This is a {@link PaginatedMessage}, a utility to paginate messages (usually embeds).
 * You must either use this class directly or extend it.
 *
 * {@link PaginatedMessage} uses {@linkplain https://discord.js.org/#/docs/main/stable/typedef/MessageComponent MessageComponent} buttons that perform the specified action when clicked.
 * You can either use your own actions or the {@link PaginatedMessage.defaultActions}.
 * {@link PaginatedMessage.defaultActions} is also static so you can modify these directly.
 *
 * {@link PaginatedMessage} also uses pages via {@linkplain https://discord.js.org/#/docs/main/stable/class/Message Messages}.
 *
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage();
 * // Once you have an instance of PaginatedMessage you can call various methods on it to add pages to it.
 * // For more details see each method's documentation.
 *
 * myPaginatedMessage.addPageEmbed((embed) => {
 *		embed
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return embed;
 * });
 *
 * myPaginatedMessage.addPageBuilder((builder) => {
 *		const embed = new MessageEmbed()
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return builder
 *			.setContent('example content')
 *			.setEmbed(embed);
 * });
 *
 * myPaginatedMessage.addPageContent('Example');
 *
 * myPaginatedMessage.run(message)
 * ```
 *
 * @remark You can also provide a MessageEmbed template. This will be applied to every page.
 * If a page itself has an embed then the two will be merged, with the content of
 * the page's embed taking priority over the template.
 *
 * Furthermore, if the template has a footer then it will be applied _after_ the page index part of the footer
 * with a space preceding the template. For example, when setting `- Powered by Sapphire Framework`
 * the resulting footer will be `1/2 - Powered by Sapphire Framework`
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage({
 * 	template: new MessageEmbed().setColor('#FF0000').setFooter('- Powered by Sapphire framework')
 * });
 * ```
 *
 * @remark To utilize actions you can implement IPaginatedMessageAction into a class.
 * @example
 * ```typescript
 * class ForwardAction implements IPaginatedMessageAction {
 *   public id = '▶️';
 *
 *   public run({ handler }) {
 *     if (handler.index !== handler.pages.length - 1) ++handler.index;
 *   }
 * }
 *
 * // You can also give the object directly.
 *
 * const StopAction: IPaginatedMessageAction = {
 *   customId: 'CustomStopAction',
 *   run: ({ collector }) => {
 *     collector.stop();
 *   }
 * }
 * ```
 */
class PaginatedMessage {
    /**
     * Constructor for the {@link PaginatedMessage} class
     * @param __namedParameters The {@link PaginatedMessageOptions} for this instance of the {@link PaginatedMessage} class
     */
    constructor({ pages, actions, template, pageIndexPrefix, embedFooterSeparator, paginatedMessageData = null } = {}) {
        /**
         * The pages to be converted to {@link PaginatedMessage.messages}
         */
        Object.defineProperty(this, "pages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The response message used to edit on page changes.
         */
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        /**
         * The collector used for handling button clicks.
         */
        Object.defineProperty(this, "collector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        /**
         * The pages which were converted from {@link PaginatedMessage.pages}
         */
        Object.defineProperty(this, "messages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * The actions which are to be used.
         */
        Object.defineProperty(this, "actions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        /**
         * The handler's current page/message index.
         */
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * The amount of milliseconds to idle before the paginator is closed. Defaults to 20 minutes.
         */
        Object.defineProperty(this, "idle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 60000 /* Minute */ * 20
        });
        /**
         * The template for this {@link PaginatedMessage}.
         * You can use templates to set defaults that will apply to each and every page in the {@link PaginatedMessage}
         */
        Object.defineProperty(this, "template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Custom text to show in front of the page index in the embed footer.
         * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
         * @default ```PaginatedMessage.pageIndexPrefix``` (static property)
         */
        Object.defineProperty(this, "pageIndexPrefix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PaginatedMessage.pageIndexPrefix
        });
        /**
         * Custom separator to show after the page index in the embed footer.
         * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
         * @default ```PaginatedMessage.embedFooterSeparator``` (static property)
         */
        Object.defineProperty(this, "embedFooterSeparator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PaginatedMessage.embedFooterSeparator
        });
        Object.defineProperty(this, "paginatedMessageData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "selectMenuOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PaginatedMessage.selectMenuOptions
        });
        Object.defineProperty(this, "wrongUserInteractionReply", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PaginatedMessage.wrongUserInteractionReply
        });
        /**
         * Tracks whether a warning was already emitted for this {@link PaginatedMessage}
         */
        Object.defineProperty(this, "hasEmittedWarning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this.pages = pages ?? [];
        for (const page of this.pages) {
            if ((0, utilities_1.isFunction)(page) || (0, utilities_1.isObject)(page)) {
                this.messages.push(page);
            }
        }
        for (const action of actions ?? this.constructor.defaultActions) {
            this.actions.set(action.customId, action);
        }
        this.template = PaginatedMessage.resolveTemplate(template);
        this.pageIndexPrefix = pageIndexPrefix ?? PaginatedMessage.pageIndexPrefix;
        this.embedFooterSeparator = embedFooterSeparator ?? PaginatedMessage.embedFooterSeparator;
        this.paginatedMessageData = paginatedMessageData;
    }
    /**
     * Sets the {@link PaginatedMessage.selectMenuOptions} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param newOptions The new options generator to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setSelectMenuOptions(newOptions) {
        this.selectMenuOptions = newOptions;
        return this;
    }
    /**
     * Sets the {@link PaginatedMessage.wrongUserInteractionReply} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param wrongUserInteractionReply The new `wrongUserInteractionReply` to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setWrongUserInteractionReply(wrongUserInteractionReply) {
        this.wrongUserInteractionReply = wrongUserInteractionReply;
        return this;
    }
    /**
     * Sets the handler's current page/message index.
     * @param index The number to set the index to.
     */
    setIndex(index) {
        this.index = index;
        return this;
    }
    /**
     * Sets the amount of time to idle before the paginator is closed.
     * @param idle The number to set the idle to.
     */
    setIdle(idle) {
        this.idle = idle;
        return this;
    }
    /**
     * Clears all current actions and sets them. The order given is the order they will be used.
     * @param actions The actions to set.
     */
    setActions(actions) {
        this.actions.clear();
        return this.addActions(actions);
    }
    /**
     * Adds actions to the existing ones. The order given is the order they will be used.
     * @param actions The actions to add.
     */
    addActions(actions) {
        for (const action of actions)
            this.addAction(action);
        return this;
    }
    /**
     * Adds an action to the existing ones. This will be added as the last action.
     * @param action The action to add.
     */
    addAction(action) {
        this.actions.set(action.customId, action);
        return this;
    }
    /**
     * Checks whether or not the handler has a specific page.
     * @param index The index to check.
     */
    hasPage(index) {
        return index >= 0 && index < this.pages.length;
    }
    /**
     * Clears all current pages and messages and sets them. The order given is the order they will be used.
     * @param pages The pages to set.
     */
    setPages(pages) {
        this.pages = [];
        this.messages = [];
        this.addPages(pages);
        return this;
    }
    /**
     * Adds a page to the existing ones. This will be added as the last page.
     * @remark While you can use this method you should first check out
     * {@link PaginatedMessage.addPageBuilder},
     * {@link PaginatedMessage.addPageContent} and
     * {@link PaginatedMessage.addPageEmbed} as
     * these are easier functional methods of adding pages and will likely already suffice for your needs.
     *
     * @param page The page to add.
     */
    addPage(page) {
        // Do not allow more than 25 pages, and send a warning when people try to do so.
        if (this.pages.length === 25) {
            if (!this.hasEmittedWarning) {
                process.emitWarning('Maximum amount of pages exceeded for PaginatedMessage. Please check your instance of PaginatedMessage and ensure that you do not exceed 25 pages total.', {
                    type: 'PaginatedMessageExceededMessagePageAmount',
                    code: 'PAGINATED_MESSAGE_EXCEEDED_MAXIMUM_AMOUNT_OF_PAGES',
                    detail: `If you do need more than 25 pages you can extend the class and overwrite the actions in the constructor.`
                });
                this.hasEmittedWarning = true;
            }
            return this;
        }
        this.pages.push(page);
        return this;
    }
    /**
     * Adds a page to the existing ones using a {@link MessageBuilder}. This will be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder((builder) => {
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbed(embed);
     * });
     * ```
     * @example
     * ```typescript
     * const { MessageEmbed } = require('discord.js');
     * const { MessageBuilder, PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const builder = new MessageBuilder()
     * 	.setContent('example content')
     * 	.setEmbed(embed);
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder(builder);
     * ```
     */
    addPageBuilder(builder) {
        return this.addPage((0, utilities_1.isFunction)(builder) ? builder(new MessageBuilder_1.MessageBuilder()) : builder);
    }
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageBuilder}. This wil be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageBuilder(async (builder) => {
     * 		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbed(embed);
     * });
     * ```
     */
    addAsyncPageBuilder(builder) {
        return this.addPage(async () => ((0, utilities_1.isFunction)(builder) ? builder(new MessageBuilder_1.MessageBuilder()) : builder));
    }
    /**
     * Adds a page to the existing ones using simple message content. This will be added as the last page.
     * @param content The content to set.
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageContent('example content');
     * ```
     */
    addPageContent(content) {
        return this.addPage({ content });
    }
    /**
     * Adds a page to the existing ones using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first parameter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed((embed) => {
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return embed;
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed(embed);
     * ```
     */
    addPageEmbed(embed) {
        return this.addPage({ embeds: (0, utilities_1.isFunction)(embed) ? [embed(new discord_js_1.MessageEmbed())] : [embed] });
    }
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first parameter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbed(async (embed) => {
     *		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return embed;
     * });
     * ```
     */
    addAsyncPageEmbed(embed) {
        return this.addPage(async () => ({ embeds: (0, utilities_1.isFunction)(embed) ? [await embed(new discord_js_1.MessageEmbed())] : [embed] }));
    }
    /**
     * Adds a page to the existing ones asynchronously using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds((embed1, embed2, embed3) => { // You can add up to 10 embeds
     * 		embed1
     * 			.setColor('#FF0000')
     * 			.setDescription('example description 1');
     *
     * 		embed2
     * 			.setColor('#00FF00')
     * 			.setDescription('example description 2');
     *
     * 		embed3
     * 			.setColor('#0000FF')
     * 			.setDescription('example description 3');
     *
     * 		return [embed1, embed2, embed3];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addPageEmbeds(embeds) {
        let processedEmbeds = (0, utilities_1.isFunction)(embeds)
            ? embeds(new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed())
            : embeds;
        if (processedEmbeds.length > 10) {
            processedEmbeds = processedEmbeds.slice(0, 10);
        }
        return this.addPage({ embeds: processedEmbeds });
    }
    /**
     * Adds a page to the existing ones using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage().addAsyncPageEmbeds(async (embed0, embed1, embed2) => {
     * 	const someRemoteData = (await fetch('https://contoso.com/api/users')) as any;
     *
     * 	for (const [index, user] of Object.entries(someRemoteData.users.slice(0, 10)) as [`${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`, any][]) {
     * 		switch (index) {
     * 			case '0': {
     * 				embed0.setColor('#FF0000').setDescription('example description 1').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '1': {
     * 				embed1.setColor('#00FF00').setDescription('example description 2').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '2': {
     * 				embed2.setColor('#0000FF').setDescription('example description 3').setAuthor(user.name);
     * 				break;
     * 			}
     * 		}
     * 	}
     *
     * 	return [embed0, embed1, embed2];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addAsyncPageEmbeds(embeds) {
        return this.addPage(async () => {
            let processedEmbeds = (0, utilities_1.isFunction)(embeds)
                ? await embeds(new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed(), new discord_js_1.MessageEmbed())
                : embeds;
            if (processedEmbeds.length > 10) {
                processedEmbeds = processedEmbeds.slice(0, 10);
            }
            return { embeds: processedEmbeds };
        });
    }
    /**
     * Add pages to the existing ones. The order given is the order they will be used.
     * @param pages The pages to add.
     */
    addPages(pages) {
        for (const page of pages)
            this.addPage(page);
        return this;
    }
    /**
     * Executes the {@link PaginatedMessage} and sends the pages corresponding with {@link PaginatedMessage.index}.
     * The handler will start collecting message button interactions.
     * @param message The message that triggered this {@link PaginatedMessage}.
     * Generally this will be the command message, but it can also be another message from your client, i.e. to indicate a loading state.
     * @param target The user who will be able to interact with the message buttons of this {@link PaginatedMessage}. Defaults to `message.author`.
     */
    async run(message, target = message.author) {
        // Try to get the previous PaginatedMessage for this user
        const paginatedMessage = PaginatedMessage.handlers.get(target.id);
        // If a PaginatedMessage was found then stop it
        if (paginatedMessage)
            paginatedMessage.collector.stop();
        // If the message was sent by a bot, then set the response as this one
        if (message.author.bot)
            this.response = message;
        await this.resolvePagesOnRun();
        // Sanity checks to handle
        if (!this.messages.length)
            throw new Error('There are no messages.');
        if (!this.actions.size)
            throw new Error('There are no messages.');
        await this.setUpMessage(message.channel, target);
        this.setUpCollector(message.channel, target);
        const messageId = this.response.id;
        if (this.collector) {
            this.collector.once('end', () => {
                PaginatedMessage.messages.delete(messageId);
                PaginatedMessage.handlers.delete(target.id);
            });
            PaginatedMessage.messages.set(messageId, this);
            PaginatedMessage.handlers.set(target.id, this);
        }
        return this;
    }
    /**
     * Executed whenever {@link PaginatedMessage.run} is called.
     */
    async resolvePagesOnRun() {
        for (let i = 0; i < this.pages.length; i++)
            await this.resolvePage(i);
    }
    /**
     * Executed whenever an action is triggered and resolved.
     * @param index The index to resolve.
     */
    async resolvePage(index) {
        // If the message was already processed, do not load it again:
        const message = this.messages[index];
        if (!(0, utilities_1.isNullish)(message)) {
            return message;
        }
        // Load the page and return it:
        const resolved = await this.handlePageLoad(this.pages[index], index);
        this.messages[index] = resolved;
        return resolved;
    }
    /**
     * Clones the current handler into a new instance.
     */
    clone() {
        const clone = new this.constructor({ pages: this.pages, actions: [] }).setIndex(this.index).setIdle(this.idle);
        clone.actions = this.actions;
        clone.response = this.response;
        clone.template = this.template;
        return clone;
    }
    /**
     * Sets up the message.
     * @param channel The channel the handler is running at.
     * @param author The author the handler is for.
     */
    async setUpMessage(channel, targetUser) {
        // Get the current page
        let page = this.messages[this.index];
        // If the page is a callback function such as with `addAsyncPageEmbed` then resolve it here
        page = (0, utilities_1.isFunction)(page) ? await page(this.index, this.pages, this) : page;
        // Merge in the advanced options
        page = { ...page, ...(this.paginatedMessageData ?? {}) };
        // If we do not have more than 1 page then there is no reason to add message components
        if (this.pages.length > 1) {
            const messageComponents = await Promise.all([...this.actions.values()].map(async (interaction) => {
                return (0, utils_1.isMessageButtonInteraction)(interaction)
                    ? new discord_js_1.MessageButton(interaction)
                    : new discord_js_1.MessageSelectMenu({
                        ...interaction,
                        options: await Promise.all(this.pages.map(async (_, index) => ({
                            ...(await this.selectMenuOptions(index + 1, {
                                author: targetUser,
                                channel,
                                guild: (0, type_guards_1.isGuildBasedChannel)(channel) ? channel.guild : null
                            })),
                            value: index.toString()
                        })))
                    });
            }));
            page.components = (0, utils_1.createPartitionedMessageRow)(messageComponents);
        }
        if (this.response) {
            await this.response.edit(page);
        }
        else {
            this.response = await channel.send(page);
        }
    }
    /**
     * Sets up the message's collector.
     * @param channel The channel the handler is running at.
     * @param targetUser The user the handler is for.
     */
    setUpCollector(channel, targetUser) {
        if (this.pages.length > 1) {
            this.collector = this.response.createMessageComponentCollector({
                filter: (interaction) => this.actions.has(interaction.customId),
                idle: this.idle
            })
                .on('collect', this.handleCollect.bind(this, targetUser, channel))
                .on('end', this.handleEnd.bind(this));
        }
    }
    /**
     * Handles the load of a page.
     * @param page The page to be loaded.
     * @param channel The channel the paginated message runs at.
     * @param index The index of the current page.
     */
    async handlePageLoad(page, index) {
        // Resolve the options from a function or an object
        const options = (0, utilities_1.isFunction)(page) ? await page(index, this.pages, this) : page;
        // Clone the template to leave the original intact
        const clonedTemplate = (0, utilities_1.deepClone)(this.template);
        // Apply the template to the page
        const optionsWithTemplate = this.applyTemplate(clonedTemplate, options);
        // Apply the footer to the embed, if any
        return this.applyFooter(optionsWithTemplate, index);
    }
    /**
     * Handles the `collect` event from the collector.
     * @param targetUser The user the handler is for.
     * @param channel The channel the handler is running at.
     * @param interaction The button interaction that was received.
     */
    async handleCollect(targetUser, channel, interaction) {
        if (interaction.user.id === targetUser.id) {
            const action = this.actions.get(interaction.customId);
            const previousIndex = this.index;
            await action.run({
                interaction,
                handler: this,
                author: targetUser,
                channel,
                response: this.response,
                collector: this.collector
            });
            const newIndex = previousIndex === this.index ? previousIndex : this.index;
            const messagePage = await this.resolvePage(newIndex);
            const updateOptions = (0, utilities_1.isFunction)(messagePage) ? await messagePage(newIndex, this.pages, this) : messagePage;
            if (interaction.replied || interaction.deferred) {
                await interaction.editReply(updateOptions);
            }
            else {
                await interaction.update(updateOptions);
            }
        }
        else {
            const interactionReplyOptions = await this.wrongUserInteractionReply(targetUser, interaction.user, {
                author: interaction.user,
                channel: interaction.channel,
                guild: interaction.guild
            });
            await interaction.reply((0, utilities_1.isObject)(interactionReplyOptions)
                ? interactionReplyOptions
                : { content: interactionReplyOptions, ephemeral: true, allowedMentions: { users: [], roles: [] } });
        }
    }
    /**
     * Handles the `end` event from the collector.
     * @param reason The reason for which the collector was ended.
     */
    handleEnd(_, reason) {
        // Remove all listeners from the collector:
        this.collector?.removeAllListeners();
        // Do not remove reactions if the message, channel, or guild, was deleted:
        if (this.response && !PaginatedMessage.deletionStopReasons.includes(reason)) {
            void this.response?.edit({ components: [] });
        }
    }
    applyFooter(message, index) {
        if (!message.embeds?.length) {
            return message;
        }
        for (const [idx, embed] of Object.entries(message.embeds)) {
            if (embed) {
                embed.footer ?? (embed.footer = { text: this.template.embeds?.[Number(idx)]?.footer?.text ?? this.template.embeds?.[0]?.footer?.text ?? '' });
                embed.footer.text = `${this.pageIndexPrefix ? `${this.pageIndexPrefix} ` : ''}${index + 1} / ${this.pages.length}${embed.footer.text ? ` ${this.embedFooterSeparator} ${embed.footer.text}` : ''}`;
            }
        }
        return message;
    }
    applyTemplate(template, options) {
        const embedData = this.applyTemplateEmbed(template.embeds, options.embeds);
        return { ...template, ...options, embeds: embedData };
    }
    applyTemplateEmbed(templateEmbed, pageEmbeds) {
        if ((0, utilities_1.isNullish)(pageEmbeds)) {
            return templateEmbed ? [templateEmbed?.[0]] : undefined;
        }
        if ((0, utilities_1.isNullish)(templateEmbed)) {
            return pageEmbeds;
        }
        return this.mergeEmbeds(templateEmbed[0], pageEmbeds);
    }
    mergeEmbeds(templateEmbed, pageEmbeds) {
        const mergedEmbeds = [];
        for (const pageEmbed of pageEmbeds) {
            mergedEmbeds.push({
                title: pageEmbed.title ?? templateEmbed.title ?? undefined,
                description: pageEmbed.description ?? templateEmbed.description ?? undefined,
                url: pageEmbed.url ?? templateEmbed.url ?? undefined,
                timestamp: (typeof pageEmbed.timestamp === 'string' ? new Date(pageEmbed.timestamp) : pageEmbed.timestamp) ??
                    (typeof templateEmbed.timestamp === 'string' ? new Date(templateEmbed.timestamp) : templateEmbed.timestamp) ??
                    undefined,
                color: pageEmbed.color ?? templateEmbed.color ?? undefined,
                fields: this.mergeArrays(templateEmbed.fields, pageEmbed.fields),
                author: pageEmbed.author ?? templateEmbed.author ?? undefined,
                thumbnail: pageEmbed.thumbnail ?? templateEmbed.thumbnail ?? undefined,
                image: pageEmbed.image ?? templateEmbed.image ?? undefined,
                video: pageEmbed.video ?? templateEmbed.video ?? undefined,
                footer: pageEmbed.footer ?? templateEmbed.footer ?? undefined
            });
        }
        return mergedEmbeds;
    }
    mergeArrays(template, array) {
        if ((0, utilities_1.isNullish)(array)) {
            return template;
        }
        if ((0, utilities_1.isNullish)(template)) {
            return array;
        }
        return [...template, ...array];
    }
    static resolveTemplate(template) {
        if (template === undefined) {
            return {};
        }
        if (template instanceof discord_js_1.MessageEmbed) {
            return { embeds: [template] };
        }
        return template;
    }
}
exports.PaginatedMessage = PaginatedMessage;
_a = PaginatedMessage;
/**
 * The default actions of this handler.
 */
Object.defineProperty(PaginatedMessage, "defaultActions", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: [
        {
            customId: '@sapphire/paginated-messages.goToPage',
            type: discord_js_1.Constants.MessageComponentTypes.SELECT_MENU,
            run: ({ handler, interaction }) => interaction.isSelectMenu() && (handler.index = parseInt(interaction.values[0], 10))
        },
        {
            customId: '@sapphire/paginated-messages.firstPage',
            style: 'PRIMARY',
            emoji: '⏪',
            type: discord_js_1.Constants.MessageComponentTypes.BUTTON,
            run: ({ handler }) => (handler.index = 0)
        },
        {
            customId: '@sapphire/paginated-messages.previousPage',
            style: 'PRIMARY',
            emoji: '◀️',
            type: discord_js_1.Constants.MessageComponentTypes.BUTTON,
            run: ({ handler }) => {
                if (handler.index === 0) {
                    handler.index = handler.pages.length - 1;
                }
                else {
                    --handler.index;
                }
            }
        },
        {
            customId: '@sapphire/paginated-messages.nextPage',
            style: 'PRIMARY',
            emoji: '▶️',
            type: discord_js_1.Constants.MessageComponentTypes.BUTTON,
            run: ({ handler }) => {
                if (handler.index === handler.pages.length - 1) {
                    handler.index = 0;
                }
                else {
                    ++handler.index;
                }
            }
        },
        {
            customId: '@sapphire/paginated-messages.goToLastPage',
            style: 'PRIMARY',
            emoji: '⏩',
            type: discord_js_1.Constants.MessageComponentTypes.BUTTON,
            run: ({ handler }) => (handler.index = handler.pages.length - 1)
        },
        {
            customId: '@sapphire/paginated-messages.stop',
            style: 'DANGER',
            emoji: '⏹️',
            type: discord_js_1.Constants.MessageComponentTypes.BUTTON,
            run: async ({ collector, response }) => {
                collector.stop();
                await response.edit({ components: [] });
            }
        }
    ]
});
/**
 * The reasons sent by {@linkplain https://discord.js.org/#/docs/main/stable/class/InteractionCollector?scrollTo=e-end InteractionCollector#end}
 * event when the message (or its owner) has been deleted.
 */
Object.defineProperty(PaginatedMessage, "deletionStopReasons", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: ['messageDelete', 'channelDelete', 'guildDelete']
});
/**
 * Custom text to show in front of the page index in the embed footer.
 * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
 * @default ""
 * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your bot.
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.pageIndexPrefix = 'Page';
 * // This will make the footer of the embed something like "Page 1/2"
 * ```
 */
Object.defineProperty(PaginatedMessage, "pageIndexPrefix", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: ''
});
/**
 * Custom separator for the page index in the embed footer.
 * @default "•"
 * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your bot.
 * Alternatively, you can also customize it on a per-PaginatedMessage basis by passing `embedFooterSeparator` in the options of the constructor.
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.embedFooterSeparator = '|';
 * // This will make the separator of the embed footer something like "Page 1/2 | Today at 4:20"
 * ```
 */
Object.defineProperty(PaginatedMessage, "embedFooterSeparator", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: '•'
});
/**
 * The messages that are currently being handled by a {@link PaginatedMessage}
 * The key is the ID of the message that triggered this {@link PaginatedMessage}
 *
 * This is to ensure that only 1 {@link PaginatedMessage} can run on a specified message at once.
 * This is important when having an editable commands solution.
 */
Object.defineProperty(PaginatedMessage, "messages", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Map()
});
/**
 * The current {@link InteractionCollector} handlers that are active.
 * The key is the ID of of the author who sent the message that triggered this {@link PaginatedMessage}
 *
 * This is to ensure that any given author can only trigger 1 {@link PaginatedMessage}.
 * This is important for performance reasons, and users should not have more than 1 {@link PaginatedMessage} open at once.
 */
Object.defineProperty(PaginatedMessage, "handlers", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Map()
});
/**
 * A generator for {@link MessageSelectOption} that will be used to generate the options for the {@link MessageSelectMenu}.
 * We do not allow overwriting the {@link MessageSelectOption#value} property with this, as it is vital to how we handle
 * select menu interactions.
 *
 * @param pageIndex The index of the page to add to the {@link MessageSelectMenu}. We will add 1 to this number because our pages are 0 based,
 * so this will represent the pages as seen by the user.
 * @default
 * ```ts
 * {
 * 	label: `Page ${pageIndex}`
 * }
 * ```
 * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your bot.
 *
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.selectMenuOptions = (pageIndex) => ({
 * 	 label: `Go to page: ${pageIndex}`,
 * 	 description: 'This is a description'
 * });
 * ```
 */
Object.defineProperty(PaginatedMessage, "selectMenuOptions", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: (pageIndex) => ({ label: `Page ${pageIndex}` })
});
/**
 * A generator for {@link MessageComponentInteraction#reply} that will be called and sent whenever an untargeted user interacts with one of the buttons.
 * When modifying this it is recommended that the message is set to be ephemeral so only the user that is pressing the buttons can see them.
 * Furthermore, we also recommend setting `allowedMentions: { users: [], roles: [] }`, so you don't have to worry about accidentally pinging anyone.
 *
 * When setting just a string, we will add `{ ephemeral: true, allowedMentions: { users: [], roles: [] } }` for you.
 *
 * @param targetUser The {@link User} this {@link PaginatedMessage} was intended for.
 * @param interactionUser The {@link User} that actually clicked the button.
 * @default
 * ```ts
 * {
 * 	content: `Please stop clicking the buttons on this message. They are only for ${Formatters.userMention(targetUser.id)}.`,
 * 	ephemeral: true,
 * 	allowedMentions: { users: [], roles: [] }
 * }
 * ```
 * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your bot.
 *
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * // We  will add ephemeral and no allowed mention for string only overwrites
 * PaginatedMessage.wrongUserInteractionReply = (targetUser) =>
 *     `These buttons are only for ${Formatters.userMention(targetUser.id)}. Press them as much as you want, but I won't do anything with your clicks.`;
 * ```
 *
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 * import { Formatters } from 'discord.js';
 *
 * PaginatedMessage.wrongUserInteractionReply = (targetUser) => ({
 * 	content: `These buttons are only for ${Formatters.userMention(
 * 		targetUser.id
 * 	)}. Press them as much as you want, but I won't do anything with your clicks.`,
 * 	ephemeral: true,
 * 	allowedMentions: { users: [], roles: [] }
 * });
 * ```
 */
Object.defineProperty(PaginatedMessage, "wrongUserInteractionReply", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: (targetUser) => ({
        content: `Please stop clicking the buttons on this message. They are only for ${discord_js_1.Formatters.userMention(targetUser.id)}.`,
        ephemeral: true,
        allowedMentions: { users: [], roles: [] }
    })
});
//# sourceMappingURL=PaginatedMessage.js.map